I am going to include some snippets of code from the NHL Hockey Source Code which deal with reading/displaying frames/sprites from the .anim format. 

Then I will include the code for my .ANIM to BMP tool for NHL Hockey, and the Readme.md for the tool detailing the file format. 

And then I will include the description of the updated addframe function from NHLPA93 & NHL94, as well as the addresses for the way the data is laid out in NHLPA93 & NHL94. 

And I will include my .ANIM to BMP tool for NHL93/94 which has a couple of issues.

I know that in NHLPA93 & NHL94, it seems like the buildframelist function is run at buildtime and is inserted into the rom, and there are some other adjusments to the file format. 

The issue I want you to focus on is palettes. The palette index is not getting selected correctly per palette. Let me give you some sample code:
Sprite data for Frame 0, Sprite 0:
FF F9 FF E7 01 E0 40 07

so the palette byte has 40 in it. I'm pretty sure if its 40, this should set the sprite to palette index 2. That being said I fully don't understand the calculation to do this, and in the script its wrong as the value is coming out as 0


----

NHL Hockey Source code:
Ram.asm:
SprStratt	=	2+8	;equates for building frame lists from alice files
SprStrhot	=	SprStratt+2
SprStrnum	=	SprStrhot+24
SprStrdat	=	SprStrnum+2

FrameList	ds.l	550	;max number of frames
Spritetiles	ds.l	1

Middle.asm:
Buildframelist
	;make a table in ram of each frames starting point
	;so as to have random acces to sprite graphics
	;a1 = animation file
	;a0 = start of ram table (1 long word/frame)

	;return a0 = tile set
	;a1 = palette data
	add	#2,a1
	move	(a1),d0	;number of frames
	add	#4,a1
.0	move.l	a1,(a0)+
	move	SprStrnum(a1),d1	;number of sprites in this frame
	asl	#3,d1
	add	#SprStrdat+8,d1
	add	d1,a1
	dbf	d0,.0

	move	2(a1),d0
	lea	2(a1),a0	;tile set

	ext.l	d0
	asl.l	#5,d0
	add.l	d0,a1	;palette
	add	#2,a1
	rts

Video.asm:
addframe
;a3 = cords.l frame/oldframe VRsize VRchar
;a5 = dma trans
;a6/d6 = sprite att
	movem.l	d0-d2,-(a7)
	move	Xpos(a3),d0
	move	Ypos(a3),d1
	move	Zpos(a3),d2
	bmi	.exit
	bsr	find3d
	cmp	#osflag,d1
	beq	.exit
	bsr	addframe2
.exit
	movem.l	(a7)+,d0-d2
	rts

addframe2
;d0/d1 = x/y coordinates on screen
	;a5 = dma list
	;a6 = sprite table
	;d6 = link counter

	movem.l	d0-d5/a0-a2,-(a7)
	move	frame(a3),d5
	bmi	.exit
	beq	.exit
	asl	#2,d5
	move	#framelist,a2
	move.l	-4(a2,d5),a2
	move	SprStrnum(a2),d5	;number of sprites in frame
	add	#SprStrdat,a2
	clr	d3
	clr	d4
.sloop
	move	d0,-(a7)
	move	frame(a3),d0
	cmp	oldframe(a3),d0
	beq	.noref

	tst	d5
	bne	.nn
	move	d0,oldframe(a3)
.nn
	movem	d0-d4,-(a7)
	move	4(a2),d2
	and	#$7ff,d2
	move	2(a2),d4
	and	#$f000,d4
	lsr	#1,d4
	or	d4,d2	;full 15 bits of data pointer

	move.b	2(a2),d4
	and	#$f,d4
	move.l	#sizetab,a0
	move.b	0(a0,d4),d4	;chars used in this sprite
	cmp	8(a7),d4
	bgt	.nodup	;more data in prev sprite so no dup
	cmp	4(a7),d2
	blt	.nodup
	move	4(a7),d0
	add	8(a7),d0	;end of last data
	sub	d2,d0
	sub	d4,d0	
	bmi	.nodup
	movem	(a7)+,d0-d1
	add	#6,a7
	bra	.dup

.nodup	add	8(a7),d3
	movem	(a7)+,d0-d1
	add	#6,a7

	movem	d0-d4,-(a7)
	add	VRchar(a3),d3
	move.l	Spritetiles,a0
	ext.l	d2
	asl.l	#5,d2
	add.l	d2,a0
	asl	#4,d4
	asl	#5,d3
	move.l	a0,(a5)+
	move	d4,(a5)+	;words to transfer
	move	d3,(a5)+	;vram destination
	movem	(a7)+,d0-d4
.dup
	move.b	d3,VRoffs(a3,d5)
.noref
	move	(a7)+,d0
	movem	d0-d2,-(a7)	;write sprite att
	move	(a2),d2	;y global
	btst	#4,attribute(a3)	;y flip
	beq	.noyflip
	move.b	2(a2),d2
	and	#%0011,d2
	add	#1,d2
	asl	#3,d2
	neg	d2
	sub	(a2),d2
.noyflip	add	d2,d1
	move	d1,(a6)

	move	6(a2),d2	;x global
	btst	#3,attribute(a3)	;x flip
	beq	.noxflip
	move.b	2(a2),d2
	and	#%1100,d2
	add	#%0100,d2
	asl	#1,d2
	neg	d2
	sub	6(a2),d2
.noxflip	add	d2,d0
	move	d0,6(a6)
	move.b	2(a2),2(a6)
	move.b	d6,3(a6)
	move	4(a2),d2
	move	attribute(a3),d0
	eor	d0,d2
	and	#$f800,d2
	btst	#0,attribute+1(a3)
	beq	.nospec
	btst	#14,d2
	beq	.nospec
	bset	#13,d2	;team 2 color
.nospec	or.b	VRoffs(a3,d5),d2
	add	VRchar(a3),d2
	move	d2,4(a6)
	movem	(a7)+,d0-d2

	add	#1,d6
	add	#8,a6
	add	#8,a2
	dbf	d5,.sloop
.exit
	movem.l	(a7)+,d0-d5/a0-a2
	rts

sizetab
	dc.b	1,2,3,4,2,4,6,8,3,6,9,12,4,8,12,16
;-------------------------------------------------
horoff	=	197

Here is my animToBmp.js script for NHL Hockey:
const fs = require('fs');

// Function to convert the compressed image to BMP format
const convertToBMP = (fileName, palFile) => {
  console.log('animToBMP:', fileName);
  fs.mkdirSync('Extracted', { recursive: true });
  fs.mkdirSync(`Extracted\\${fileName}`, { recursive: true });

  console.log("Converting "+fileName+ " to BMP");
  const animData = fs.readFileSync(fileName);
  const fileType = animData.toString('ascii', 0, 2);
  const numFrames = animData.readInt16BE(2)+1;
  const u0 = animData.readInt16BE(4)+1;
  console.log("fileType",fileType,"numFrames",numFrames,"u0",u0);

  // Initialize frames array
  const frames = new Array(numFrames); // Pre-allocate for efficiency

  // Store the header information in a JSON file
  const headerInfo = { fileType, numFrames, u0};
  fs.writeFileSync(`Extracted\\${fileName}\\${fileName}.json`, JSON.stringify(headerInfo));

  var currentIndex = 6;
  for (var currentFrame=0; currentFrame<numFrames; currentFrame++) {
    console.log('currentIndex',currentIndex);
    // Initialize frame object
    const frame = {
      frameIndex: currentFrame,
      sprites: []
    };

    // Read frame header and attributes
    frame.frameHeader = animData.toString('ascii', currentIndex, currentIndex + 2);
    currentIndex += 2;
    frame.u1 = animData.readInt16BE(currentIndex); currentIndex += 2; // 02-03
    frame.u2 = animData.readInt16BE(currentIndex); currentIndex += 2; // 04-05
    frame.doubleCanvasWidth = animData.readInt16BE(currentIndex); currentIndex += 2; // 06-07
    frame.sprStrAtt = animData.readInt16BE(currentIndex); currentIndex += 2; //08-09
    frame.sprStrHot = animData.readInt16BE(currentIndex); currentIndex += 2; //10
    frame.sprStrXHot = animData.readInt16BE(currentIndex); currentIndex += 2;//12
    frame.sprStrYHot = animData.readInt16BE(currentIndex); currentIndex += 2;//14
    frame.u4 = animData.readInt16BE(currentIndex); currentIndex += 2;//16
    frame.u5 = animData.readInt16BE(currentIndex); currentIndex += 2;//18
    frame.u6 = animData.readInt16BE(currentIndex); currentIndex += 2;//20
    frame.u7 = animData.readInt16BE(currentIndex); currentIndex += 2;//22
    frame.frXoff = animData.readInt16BE(currentIndex); currentIndex += 2;//24
    frame.frYoff = animData.readInt16BE(currentIndex); currentIndex += 2;//26
    frame.u10 = animData.readInt16BE(currentIndex); currentIndex += 2;//28
    frame.u11 = animData.readInt16BE(currentIndex); currentIndex += 2;//30
    frame.u12 = animData.readInt16BE(currentIndex); currentIndex += 2;//32
    frame.u13 = animData.readInt16BE(currentIndex); currentIndex += 2;//34
    frame.numSpritesinFrame = animData.readInt16BE(currentIndex) + 1; currentIndex += 2;//36

    console.log("Frame #",currentFrame,frame);
    for (var currentSprite=0; currentSprite<frame.numSpritesinFrame; currentSprite++) {
      const sprite = {
        spriteIndex: currentSprite,
        ypos: animData.readInt16BE(currentIndex),
        sizetabByte: animData.readInt16BE(currentIndex + 2),
        tileLocByte: animData.readInt16BE(currentIndex + 4),
        xpos: animData.readInt16BE(currentIndex + 6)
      };
      currentIndex += 8;

      // Get parsed data and merge into sprite object
      const parsedData = parseSpriteData(sprite.sizetabByte, sprite.tileLocByte);
      Object.assign(sprite, parsedData); // Merge parsed key/value pairs into sprite

      frame.sprites.push(sprite);
      console.log(sprite);
      if (sprite.priority == 1) { throw new Exception('priority bit used'); }
    }
    frames[currentFrame] = frame;
  }
  
  // currentIndex = 35108; // Sprite.anim start of tile data
  var tileHeader = animData.toString('ascii', currentIndex, currentIndex+2);
  currentIndex = currentIndex + 2;
  var numTiles = animData.readInt16BE(currentIndex);
  currentIndex = currentIndex + 2;
  console.log("Tile Data Header", tileHeader, "numTiles", numTiles);
  const spriteTilesIndex = currentIndex;
  
 // Skip to palette data
  currentIndex = currentIndex + numTiles * 32;
  var palHeader = animData.toString('ascii', currentIndex, currentIndex + 2);
  currentIndex = currentIndex + 2;
  console.log('palette header', palHeader);

  // Array to store individual palettes and combined palette
  const palettes = [];
  const combinedPalette = Buffer.alloc(64 * 3); // 64 colors (16 per palette * 4 palettes), 3 bytes each (R,G,B)

  // Read palette file if provided
  let overridePalette = null;
  if (palFile) {
    const palData = fs.readFileSync(palFile);
    if (palData.length !== 32) {
      throw new Error(`Palette file ${palFile} must contain exactly 32 bytes (16 colors). Found ${palData.length} bytes.`);
    }
    overridePalette = Buffer.alloc(16 * 3); // 16 colors, 3 bytes each (R,G,B)
    for (let i = 0; i < 16; i++) {
      const color = palData.readUInt16BE(i * 2); // Read big-endian 16-bit value
      const blue = (color >> 9) & 0x07;  // Bits 9–11
      const green = (color >> 5) & 0x07; // Bits 5–7
      const red = (color >> 1) & 0x07;   // Bits 1–3
      const scaledRed = red * 32;
      const scaledGreen = green * 32;
      const scaledBlue = blue * 32;
      const offset = i * 3;
      overridePalette.writeUInt8(scaledRed, offset);
      overridePalette.writeUInt8(scaledGreen, offset + 1);
      overridePalette.writeUInt8(scaledBlue, offset + 2);
    }
    console.log(`Palette file ${palFile} read and parsed for palette 2 override.`);
  }

  for (var palIndex = 0; palIndex < 4; palIndex++) {
    var animPal = Buffer.alloc(16 * 3); // 16 colors, 3 bytes (R,G,B) each
    if (palIndex === 2 && overridePalette) {
      // Use the override palette for palette 2
      overridePalette.copy(animPal, 0, 0, 16 * 3);
      console.log(`Palette ${palIndex} overridden with palette file:`, animPal);
    } else {
      // Read from animData
      for (var colorIndex = 0; colorIndex < 16; colorIndex++) {
        // Read 2 bytes for each color (9-bit palette stored in 16 bits)
        const color = animData.readUInt16BE(currentIndex);
        currentIndex += 2;

        // Extract 3-bit components (Sega Genesis palette format: 0000BBB0GGG0RRR0)
        const blue = (color >> 9) & 0x07;  // Bits 9–11
        const green = (color >> 5) & 0x07; // Bits 5–7
        const red = (color >> 1) & 0x07;   // Bits 1–3

        // Scale 3-bit values (0–7) to 8-bit (0–255) by multiplying by 32
        const scaledRed = red * 32;
        const scaledGreen = green * 32;
        const scaledBlue = blue * 32;

        // Write RGB values to animPal buffer
        const offset = colorIndex * 3;
        animPal.writeUInt8(scaledRed, offset);
        animPal.writeUInt8(scaledGreen, offset + 1);
        animPal.writeUInt8(scaledBlue, offset + 2);
      }
      console.log(`Palette ${palIndex} read from animData:`, animPal);
    }

    // Write to combined palette (colors 0-15 for pal 0, 16-31 for pal 1, etc.)
    const combinedOffset = palIndex * 16 * 3;
    animPal.copy(combinedPalette, combinedOffset, 0, 16 * 3);

    palettes.push(animPal); // Store the individual palette

    // Write palette to .ACT file
    const actBuffer = Buffer.alloc(768); // 256 colors (768 bytes), no footer
    animPal.copy(actBuffer, 0, 0, 16 * 3); // Copy 16 RGB triplets
    fs.writeFileSync(`Extracted\\${fileName}\\pal${palIndex}.act`, actBuffer);
  }

   // Skip palette 2 data in animData if overridden
   if (overridePalette) {
    currentIndex += 32; // 16 colors * 2 bytes
  }

  // Write combined palette to .ACT file
  const combinedActBuffer = Buffer.alloc(768); // 256 colors (768 bytes), no footer
  combinedPalette.copy(combinedActBuffer, 0, 0, 64 * 3); // Copy 64 RGB triplets
  fs.writeFileSync(`Extracted\\${fileName}\\palCombined.act`, combinedActBuffer);
  
  for (var currentFrame=0; currentFrame<numFrames; currentFrame++) { // populate tile data & save image
    var minX; var maxX;
    var minY; var maxY;
    var length;
    var width;
     console.log('AA TEST',currentFrame,frames[currentFrame]);
    for (var currentSprite=0; currentSprite<frames[currentFrame].sprites.length; currentSprite++) {
      console.log('AA2','frame',currentFrame,'sprite',currentSprite, frames[currentFrame].sprites[currentSprite].dimensions);
      var curMinX = frames[currentFrame].sprites[currentSprite].xpos;
      var curMaxX = (frames[currentFrame].sprites[currentSprite].dimensions.width * 8) + curMinX;
      var curMinY = frames[currentFrame].sprites[currentSprite].ypos;
      var curMaxY = (frames[currentFrame].sprites[currentSprite].dimensions.height * 8) + curMinY;

      if (minX == null || curMinX < minX) {
        minX = curMinX
      }
      if (maxX == null || curMaxX > maxX) {
        maxX = curMaxX
      }
      if (minY == null || curMinY < minY) {
        minY = curMinY
      }
      if (maxY == null || curMaxY > maxY) {
        maxY = curMaxY
      }
      console.log(curMinX, curMaxX, curMinY, curMaxY);
    }
    console.log('original canvas dimensions',minX,maxX,minY,maxY);
    var frameDimensions = adjustCanvasDimensions(minX,maxX,minY,maxY);
    console.log('adjusted canvas',frameDimensions);

    var spriteCanvas = Array(frameDimensions.maxY).fill().map(() => Array(frameDimensions.maxX).fill(0));
    console.log('Rows:', spriteCanvas.length, 'Columns:', spriteCanvas[0].length);
    // print2DArray(spriteCanvas);

    for (var currentSpriteIndex=0; currentSpriteIndex<frames[currentFrame].sprites.length; currentSpriteIndex++) { // lay pixels into canvas
      var sprite = frames[currentFrame].sprites[currentSpriteIndex];
      
      var spriteOffset = spriteTilesIndex + sprite.tileIndex * 32;
      var idx = spriteOffset;
      console.log('Place Sprite',currentSpriteIndex,'tileIndex',sprite.tileIndex,'at',sprite.xpos+frameDimensions.offsetX,sprite.ypos+frameDimensions.offsetY,'size',sprite.dimensions,'fileOffset',spriteOffset);
      
      for (var curSpriteCol=0; curSpriteCol<sprite.dimensions.width; curSpriteCol++) {
        for (var curSpriteRow=0; curSpriteRow<sprite.dimensions.height; curSpriteRow++) {
          console.log('currentTile',curSpriteCol+curSpriteRow+1,'of',sprite.dimensions.width*sprite.dimensions.height);
          for (var curTileRow=0; curTileRow<8; curTileRow++) { // Y
            for (var curTileCol=0; curTileCol<4; curTileCol++) { // 
              // Calculate base pixel coordinates within the sprite (unflipped)
              var pixelXInSprite = (curSpriteCol * 8) + (curTileCol * 2);
              var pixelYInSprite = (curSpriteRow * 8) + curTileRow;

              // Apply flipping across the entire sprite
              var flippedX = sprite.hFlip == true ? (sprite.dimensions.width * 8 - pixelXInSprite - 2) : pixelXInSprite;
              var flippedY = sprite.vFlip == true ? (sprite.dimensions.height * 8 - pixelYInSprite - 1) : pixelYInSprite;

              // Calculate final canvas coordinates
              var ypixel = sprite.ypos + frameDimensions.offsetY + flippedY;
              var xpixel = sprite.xpos + frameDimensions.offsetX + flippedX;

              // Read the byte at the current index
              const byte = animData[idx];

              // Upper 4 bits: Shift right by 4 to get the high nibble
              const upper = (byte >> 4) & 0x0F;
              // Lower 4 bits: Mask with 0x0F to get the low nibble
              const lower = byte & 0x0F;
              // Offset Palette so that the right palette colors are used -- required because frames can be multi-palette
              const palShift = (16*sprite.paletteIndex);

              // console.log('idx', idx, 'yxpixels', ypixel, xpixel, 'byte', byte, 'upper/lower', upper, lower);
              // console.log(`${idx} = spriteOffset ${spriteOffset} + curTileRow*4 ${curTileRow*4} + curTileCol ${curTileCol} + curSpriteRow*16 ${curSpriteRow*16} + (curSpriteCol*sprite.dimensions.height*16) ${curSpriteCol*sprite.dimensions.height*16}`);
              
              // Assign pixels to canvas, swapping upper/lower for hFlip
              if (sprite.hFlip) { // if != 0 statements ensures transparency works
                if (lower != 0) { spriteCanvas[ypixel][xpixel] = lower+palShift; } // Swap upper and lower nibbles
                if (upper != 0) { spriteCanvas[ypixel][xpixel + 1] = upper+palShift; }
              } else {
                if (upper != 0) { spriteCanvas[ypixel][xpixel] = upper+palShift; }
                if (lower != 0) { spriteCanvas[ypixel][xpixel + 1] = lower+palShift; }
              }

              idx++;
            }
          }
          if(currentFrame==80) { 
            print2DArray(spriteCanvas);
          }
        }
      }
    }

    minX = null;
    maxX = null;
    minY = null;
    maxY = null;

    saveImage(spriteCanvas,frameDimensions.maxX,frameDimensions.maxY,fileName,currentFrame,combinedPalette);
    fs.writeFileSync(`Extracted\\${fileName}\\${currentFrame}.json`, JSON.stringify(frames[currentFrame]));
  }

  function adjustCanvasDimensions(minX, maxX, minY, maxY) {
    const width = maxX - minX;
    const height = maxY - minY;
    const offsetX = -minX; // Amount to shift X coordinates
    const offsetY = -minY; // Amount to shift Y coordinates
    
    return {
        minX: 0,
        minY: 0,
        maxX: width,
        maxY: height,
        offsetX: offsetX,
        offsetY: offsetY
    };
  }
  // 32 bytes per tile; 5646 tiles = 180672 bytes
  // 35108 + 180672 = 215780 = 0x34AE4 <-- start of palette data
};

// sizetab table from assembly: maps size index (0–15) to number of 8x8 tiles
const sizetabTable = [1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12, 4, 8, 12, 16];

// Dimensions table: maps size index to { width, height } in tiles
const dimensionsTable = [
  { width: 1, height: 1 }, // 1 tile
  { width: 1, height: 2 }, // 2 tiles
  { width: 1, height: 3 }, // 3 tiles
  { width: 1, height: 4 }, // 4 tiles
  { width: 2, height: 1 }, // 2 tiles
  { width: 2, height: 2 }, // 4 tiles
  { width: 2, height: 3 }, // 6 tiles
  { width: 2, height: 4 }, // 8 tiles
  { width: 3, height: 1 }, // 3 tiles
  { width: 3, height: 2 }, // 6 tiles
  { width: 3, height: 3 }, // 9 tiles
  { width: 3, height: 4 }, // 12 tiles
  { width: 4, height: 1 }, // 4 tiles
  { width: 4, height: 2 }, // 8 tiles
  { width: 4, height: 3 }, // 12 tiles
  { width: 4, height: 4 }  // 16 tiles
];

// Function to parse sizetab and tileLoc fields
function parseSpriteData(sizetabByte, tileLocByte) {
  // Extract size index (low nibble, bits 0–3)
  const sizeIndex = (sizetabByte >> 8) & 0xF;

  // Ensure inputs are 16-bit unsigned integers
  sizetab = sizetabByte & 0xFFFF;
  tileLoc = tileLocByte & 0xFFFF;

  // Get number of tiles from sizetab table
  const tileCount = sizetabTable[sizeIndex];

  // Get dimensions from dimensions table
  const dimensions = dimensionsTable[sizeIndex];

  // Extract tile index high bit (bit 15 of sizetab)
   // Extract tile index high bits (mimic assembly: sizetab & 0xF000, lsr #1)
   const tileIndexHigh = (sizetab & 0xF000) >> 1; // Bits 12–15 shifted to 11–14

  // Extract tile index low bits (bits 0–10 of tileLoc)
  const tileIndexLow = tileLocByte & 0x07FF;

  // Combine to form 15-bit tile index
  const tileIndex = tileIndexHigh | tileIndexLow;

  // Extract potential flip/priority flags (bits 11,12,15 of tileLoc)
  const priority = (tileLocByte >> 15) & 1;
  const vFlip = (tileLocByte >> 12) & 1;
  const hFlip = (tileLocByte >> 11) & 1;

  // Extract palette from bits 13–14 of tileLoc
  const paletteIndex = (tileLocByte >> 13) & 0x3; // Bits 13–14, masked to get 2-bit value (0–3)

  // Extract middle bits (4–11) of sizetab, possibly unused
  const middleBits = (sizetabByte & 0x0FF0) >> 4;

  // Return all extracted data
  return {
    sizeIndex,          // Index into sizetab table (0–15)
    tileCount,          // Number of 8x8 tiles (1–16)
    dimensions,         // { width, height } in tiles
    tileIndex,          // 15-bit tile index for tile data section
    hFlip,              // Horizontal flip flag (speculative)
    vFlip,              // Vertical flip flag (speculative)
    paletteIndex,            // Palette of Sprite
    priority,           // 1 = high, 0 = low
    middleBits          // Bits 4–11, possibly unused
  };
}

const animFile = process.argv[2];
const palFile = process.argv[3]; // Optional palette file to override palette 2
convertToBMP(animFile, palFile);

function print2DArray(array2D) {
  // Find the longest number for padding
  const maxLength = Math.max(...array2D.flat().map(num => String(num).length));
  
  // Print each row with aligned columns
  array2D.forEach(row => {
    console.log(row.map(num => String(num).padStart(maxLength, ' ')).join(' | '));
  });
}

function saveImage(spriteArray, width, height, fileName, currentFrame, combinedPalette) {
  // Create a Buffer to store the BMP image data
  const bmpWidth = Math.ceil(width / 4) * 4; // Round up width to nearest multiple of 4 for BMP pixel data format
  const bmpHeaderLength = 40;
  const bmpPadding = 14;
  const fullBmpHeaderLength = bmpHeaderLength + bmpPadding; // Header + padding
  const palLength = 256 * 4; // 256 colors, 4 bytes each (RGBA)
  const unevenImagePadding = (bmpWidth - width) * height;
  const bmpEOFLength = 2;
  const pixelDataLength = width * height;
  const expectedBmpLength = fullBmpHeaderLength + palLength + pixelDataLength + unevenImagePadding + bmpEOFLength;
  const expectedRawLength = pixelDataLength;
  console.log("expected BMP length", expectedBmpLength, "expected raw length", expectedRawLength);
  const bmpImage = Buffer.alloc(expectedBmpLength);
  const rawImage = Buffer.alloc(expectedRawLength);

  // Write the BMP header to the buffer
  bmpImage.write('BM'); // BMP Identifier
  bmpImage.writeUInt32LE(expectedBmpLength, 2); // File Size
  bmpImage.writeUInt32LE(fullBmpHeaderLength + palLength, 10); // Byte Offset to Start of Image
  bmpImage.writeUInt32LE(bmpHeaderLength, 14); // Size of Header
  bmpImage.writeInt32LE(width, 18); // Image Width
  bmpImage.writeInt32LE(height * -1, 22); // Image Height (negative for top-down)
  bmpImage.writeUInt16LE(1, 26); // Bit Planes
  bmpImage.writeUInt16LE(8, 28); // Bits/Pixel (8-bit indexed)
  bmpImage.writeUInt32LE(pixelDataLength + unevenImagePadding + bmpEOFLength, 34); // Size of pixel data

  // Write the combined palette to the BMP
  for (let i = 0; i < 64; i++) {
    const offset = i * 3;
    // BMP palette is in BGRA order
    bmpImage.writeUInt8(combinedPalette[offset + 2], fullBmpHeaderLength + i * 4); // B
    bmpImage.writeUInt8(combinedPalette[offset + 1], fullBmpHeaderLength + i * 4 + 1); // G
    bmpImage.writeUInt8(combinedPalette[offset], fullBmpHeaderLength + i * 4 + 2); // R
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 3); // A (unused)
  }
  // Fill remaining palette entries (64–255) with black
  for (let i = 64; i < 256; i++) {
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4); // B
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 1); // G
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 2); // R
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 3); // A
  }

  // Write pixel data
  let bufferIndex = fullBmpHeaderLength + palLength;
  let rawIndex = 0;
  let rowCounter = 0;

  for (var yidx = 0; yidx < height; yidx++) {
    for (var xidx = 0; xidx < width; xidx++) {
      let color = spriteArray[yidx][xidx];
      bmpImage.writeUInt8(color, bufferIndex++);
      rowCounter++;
      if (rowCounter == width && unevenImagePadding !== 0) {
        for (let j = 0; j < bmpWidth - width; j++) {
          bmpImage.writeUInt8(0, bufferIndex++); // Padding bytes
        }
        rowCounter = 0;
      }
      rawImage.writeUInt8(color, rawIndex++);
    }
  }

  // Write the BMP image data to a file
  fs.writeFileSync(`Extracted\\${fileName}\\${currentFrame}.bmp`, bmpImage);
  // Write the RAW image data to a file
  fs.writeFileSync(`Extracted\\${fileName}\\${currentFrame}.raw`, rawImage);

  if (bmpImage.length !== expectedBmpLength) {
    console.log('ERROR BMP');
    throw new Error(`Expected BMP Length ${expectedBmpLength} does not match actual length ${bmpImage.length}`);
  }
  if (rawImage.length !== expectedRawLength) {
    console.log('ERROR RAW');
    throw new Error(`Expected RAW Length ${expectedRawLength} does not match actual length ${rawImage.length}`);
  }
}

Here is the readme.md for the ANIM-To-BMP script:
# ANIM-To-BMP v0.2
Exports In-game sprites from NHL92 Sega Genesis in ANIM format to Photoshop RAW and Windows BMP format.

There is also a `.json` file saved per Animation Frame, which contains the metadata associated with each Frame. 

Palette is structured similar to how it is stored by the game in Sega Genesis CRAM. The reason is that sprites can have multiple palettes, and the only way to get multi-palette sprites to dislpay correctly would be to use the same palette structure that the game uses.

# Usage
1. Ensure you have `node` installed on your machine

2. Run `node animToBmp <animfile>` or `node animToBmp <animfile> Palettes\<Palette File>`. It will decompress the ANIM file and you will get a `.raw` (Photoshop RAW), `.json` (additonal image attributes) and a `.bmp` file in the `Extracted` path. If a palette file (included in Palettes path) was specified, it will override the player sprite Palette in extracting frames from ANIM files.

## NHL92 ANIM file details (Big Endian)
| Byte (All values in hexadecimal)              | Value           | Description |
| --------          | -------         | -------     |
| `0x00-01`         | `"AA"`          | Alice Animation Header |
| `0x02-03`         | `<int16>`      | Number of Frames in ANIM file - 1 |
| `0x04-05`         | `<int16>`      | Number of ??? - 1 |
| `0x06-FrameDataEnd`          | `<Frame Data>`  | List of Frames in .ANIM file |
| `0x(FrameDataEnd+1)-(FrameDataEnd+2)`   | `"CC"`          | Character Content (Tile Data) Header |
| `0x(FrameDataEnd+3)-(FrameDataEnd+4)`   | `<int16>`      | Number of Tiles in ANIM file  |
| `0x(FrameDataEnd+5)-(TileDataEnd)`     | `<Sprite Tile Data>`   | 8x8 Tiles, 4 bits per pixel, Column-Major order. In the retail ROM, sprites are grouped together in order of descending height. See `Size Table` Definition Section for Sprite Sizes. Sprites seem to be in opposite order of tileIndex in each size group. |
| `0x(TileDataEnd+1)-(TileDataEnd+2)`   | `"PP"`          | Palette Section Header |
| `0x(TileDataEnd+3)-(TileDataEnd+82)` | `<Palette Data>` | 128 bytes of Palette Data. Unknown as to how this is laid out. Potentially 4 palettes of 16 colors (2 bytes per color, RGB444)-- need to verify |
| `0x(TileDataEnd+83)-(TileDataEnd+84)`| `"DD"`          | Unknown Data Section Header |
| `0x(TileDataEnd+85)-(TileDataEnd+94)`| `<DD Data>` | 16 bytes of Unknown Data |
| `0x(TileDataEnd+95)-(TileDataEnd+96)`| `"ZZ"`          | End of File Footer |

### `Frame Data` Section
| Byte (All values in hexadecimal)              | Value           | Description |
| --------          | -------         | -------     |
| `0x00-01`         | `"SS"`          | Sprite Struct Header |
| `0x02-03`         | `<int16>`      | Unknown Data |
| `0x04-05`         | `<int16>`      | Unknown Data |
| `0x06-07`         | `<int16>`      | Seems to correlate with `Canvas Width * 2` |
| `0x08-09`         | `<int16>`      | Sprite Struct Attributes. Seems to correlate with `Canvas Height * 2` |
| `0x0A-0B`         | `<int16>`      | Sprite Struct Hotspot |
| `0x0C-0D`         | `<int16>`      | Sprite Struct X Hotspot |
| `0x0E-0F`         | `<int16>`      | Sprite Struct Y Hotspot |
| `0x10-17`         | `0x00 0xFF 0x00 0x00 0x00 0x00 0x00 0xFF`      | Padding |
| `0x18-19`         | `<int16>`      | Unknown Data. Potential X Offset |
| `0x1A-1B`         | `<int16>`      | Unknown Data. Potential Y Offset |
| `0x1C-1D`         | `<int16>`      | Unknown Data |
| `0x1E-23`         | `0x00 0x00 0x00 0x00 0x00 0xFF`      | Padding |
| `0x24-25`         | `<int16>`      | Number of Sprites in Frame - 1 |
| `0x26-26+(8*numSpritesinFrame)`          | `<Sprite Data>`  | Each Sprite in frame takes up 8 bytes of Data |

### `Sprite Data` Section
| Byte (All values in hexadecimal)              | Value           | Description |
| --------          | -------         | -------     |
| `0x00-01`         | `<int16>`       | Y Position of Sprite within Frame |
| `0x02-03`         | `<int16>`:`Bits 0-3`      | Size Index (0-15), references `sizetab` for number of tiles, e.g.1,2,4, etc|
| `0x02-03`         | `<int16>`:`Bits 12-15`      | These are `Bits 11-14` of the `tileIndex`  |
| `0x04-05`         | `<int16>`:`Bits 0-10`      | These are `Bits 0-10` of the `tileIndex`|
| `0x04-05`         | `<int16>`:`Bit 11`      | Horizontal Flip (`1` = flip horizontally, `0` = normal). |
| `0x04-05`         | `<int16>`:`Bit 12`      | Vertical Flip (`1` = flip vertically, `0` = normal). |
| `0x04-05`         | `<int16>`:`Bits 13-14`      | Palette Index (0–3, selects one of 4 CRAM palettes). |
| `0x04-05`         | `<int16>`:`Bit 15`      | Priority (`1` = high, appears in front; `0` = low, appears behind). |
| `0x06-07`         | `<int16>`      | X Position of Sprite within Frame |

### `Size Table` Definition
```// value at index indicates number of 8x8 tiles. Index references sizetab lookup table
sizeTab = [1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12, 4, 8, 12, 16]

// Dimensions table: maps size index to { width, height } in tiles
const dimensionsTable = [
  { width: 1, height: 1 }, // 1 tile
  { width: 1, height: 2 }, // 2 tiles
  { width: 1, height: 3 }, // 3 tiles
  { width: 1, height: 4 }, // 4 tiles
  { width: 2, height: 1 }, // 2 tiles
  { width: 2, height: 2 }, // 4 tiles
  { width: 2, height: 3 }, // 6 tiles
  { width: 2, height: 4 }, // 8 tiles
  { width: 3, height: 1 }, // 3 tiles
  { width: 3, height: 2 }, // 6 tiles
  { width: 3, height: 3 }, // 9 tiles
  { width: 3, height: 4 }, // 12 tiles
  { width: 4, height: 1 }, // 4 tiles
  { width: 4, height: 2 }, // 8 tiles
  { width: 4, height: 3 }, // 12 tiles
  { width: 4, height: 4 }  // 16 tiles
];
```

Here is a reverse engineered version of addframe2 from NHL94 a friend of mine with his notes:
NHL94 addframe2 (NHL93 is the same code, just different addresses):

Move frame into d4, pass top 5 bits.
EOR d4 with attribute (used for palette later)
Frame back into d4, pass first 11 bits
Move address $5DE7A into a2
Add long word at offset 4 to a2 address ($408AA) - $5DE7A+$408AA = $9E724
Add d4 (frame) to itself
Compare data at 2+a2 ($9E726 - $69E) to d4. Might be max length 
Exit if d4 greater than
Move data at 2+a2+d4 into d5
Sub data at a2+d4 from d5.
Divide d5 by 8, and subtract 1. d5 now has # of sprites in frame (SprStrNum)?
Add data at a2+d4 to a2 (moves to the SprStrdat)

Then it checks if frame is the same as old frame, and will update old frame if on the last sprite in the frame.

a2 now at the Sprite tile data bytes (SprStrdat)
Move bytes 4-5 into d2 (tile pointer)
Move byte 7 into d4 (sizetab byte)
Use d4 as index to sizetab table, and put # tiles into d4

Then it compares to previous d4 and branches if larger. If not, it will do a check if the tile is smaller, than branch. 
If it's the same, and the data is pointing at the same tiles, it will branch to the dup code.

Take d2, mult by 32 decimal. 
Add the Spritetiles address ($5DE84) to d2. d2 now holds the address of the first sprite tile.

Here is how the data is laid out in NHLPA93 & NHL94:
NHL94 addresses:

$5B1C-$76B2: SPAList
$5DE84-$9E724: Sprite tiles
$9E724-$9EDC2: Frame sprite data offsets ($69E long)
$9EDC2-$A44C8: Sprite data bytes
$A44C8-$A4B54: Hotlist table ($68C long)

NHL93 addresses (v1.1 ROM):
$4D8E-$6446: SPAList
$3A3B0-$6FAF0: Sprite tiles
$6FAF0-$70006: Frame sprite data offsets ($514 long)
$70006-$743FC: Sprite data bytes
$743FC-$74910: Hotlist table ($514 long, last 10 bytes are 0) 

$3A3A6 + 4 = offset to frame data table $3574A ($3A3A6+$3574A=$6FAF0)

Sprite tile data bytes (same for 93/94):
Byte 0-1: X Global
Byte 2-3: Y Global
Byte 4-5: Tile offset
Byte   6: Used when setting palette 
Byte   7: Sizetab byte  

Here is my animToBmp script for NHLPA93/NHL94:
const fs = require('fs');
const crc32 = require('crc-32'); // Install via `npm install crc-32`

// ROM configuration
const ROM_CONFIG = {
  NHLPA93: {
    name: 'NHLPA93 (v1.1)',
    crc32: 0xf361d0bf,
    expectedSize: 0x80000, // 512 kb
    addresses: {
      //spaList: { start:0x4D8E, end: 0x6446, length: 0xA }, // 5816 bytes -> should be 5810 or 5820
      spaList: { start:0x4D8E, end: 0x6440, length: 0xA },
      frameOffsets: { start: 0x6FAF2, end: 0x70006 }, // 0x514 bytes
      spriteData: { start: 0x70006, end: 0x743FC },
      hotlist: { start: 0x743FC, end: 0x74910 },
      spriteTiles: { start: 0x3A3B0, end: 0x6FAF0 },
      paletteOffset: { start: 0x35E50 } // 0x4560 before spriteTiles
    },
  },
  NHL94: {
    name: 'NHL94',
    crc32: 0x9438f5dd,
    expectedSize: 0x100000, // 1 MB (adjust if 2 MB)
    addresses: {
      //spaList: { start:0x5B1C, end: 0x76B2 },
      spaList: { start:0x5B1C, end: 0x76B0, length: 0xA },
      frameOffsets: { start: 0x9E724, end: 0x9EDC2 }, // 0x69E bytes
      spriteData: { start: 0x9EDC2, end: 0xA44C8 },
      hotlist: { start: 0xA44C8, end: 0xA4B54 },
      spriteTiles: { start: 0x5DE84, end: 0x9E724 },
      paletteOffset: { start: 0x59924 }, // same as 93,  0x4560 before spriteTiles
      paletteOffset2: { start: 0x4E298 },
      paletteOffset3: { start: 0xA5A1E },
      paletteOffset4: { start: 0xA98CC },
      paletteOffset5: { start: 0xB8A0A }, // same as 93
      paletteOffset6: { start: 0xBBE78 },
      paletteOffset7: { start: 0xBDAE6 },
      paletteOffset8: { start: 0xBEE34 },
      paletteOffset9: { start: 0xBF0E2 },
      paletteOffset10: { start: 0xBF66C },
      paletteOffset11: { start: 0xEA6D6 },
      paletteOffset12: { start: 0xEAF9A },
      paletteOffset13: { start: 0xEBE60 },
      paletteOffset14: { start: 0xEC7EE },
      paletteOffset15: { start: 0xED7FA } // same as 93
    },
  },
};
const frameOffsetHeaderLength = 2;
// Function to convert ROM sprite data to BMP format
const convertRomToBMP = (romFile, palFile) => {
  console.log('romSpriteToBMP:', romFile);
  fs.mkdirSync('Extracted', { recursive: true });

  // Read ROM and verify
  const romData = fs.readFileSync(romFile);
  const romSize = romData.length;
  const romCrc = crc32.buf(romData) >>> 0; // Convert to unsigned 32-bit

  // Detect ROM type
  let romConfig;
  if (romSize === ROM_CONFIG.NHLPA93.expectedSize && romCrc === ROM_CONFIG.NHLPA93.crc32) {
    romConfig = ROM_CONFIG.NHLPA93;
  } else if (romSize === ROM_CONFIG.NHL94.expectedSize && romCrc === ROM_CONFIG.NHL94.crc32) {
    romConfig = ROM_CONFIG.NHL94;
  } else {
    throw new Error(
      `Invalid ROM. Expected NHLPA93 (size: ${ROM_CONFIG.NHLPA93.expectedSize}, CRC32: ${ROM_CONFIG.NHLPA93.crc32.toString(16)}) ` +
      `or NHL94 (size: ${ROM_CONFIG.NHL94.expectedSize}, CRC32: ${ROM_CONFIG.NHL94.crc32.toString(16)}). ` +
      `Got size: ${romSize}, CRC32: ${romCrc.toString(16)}.`
    );
  }
  console.log(`Detected ROM: ${romConfig.name}`);

  fs.mkdirSync(`Extracted\\${romConfig.name}`, { recursive: true });

  // Calculate number of frames
  const frameTableSize = romConfig.addresses.frameOffsets.end - romConfig.addresses.frameOffsets.start;
  // 4 bytes per frame (2 for numSprites, 2 for offset), last frame is dummy
  const numFrames = (frameTableSize / 2) - 1; 
  console.log(`Number of frames: ${numFrames}`);

  // Initialize frames array
  const frames = new Array(numFrames);

  // Read frame offsets and sprite counts
  currentIndex = romConfig.addresses.frameOffsets.start;
  for (let currentFrame = 0; currentFrame < 2; currentFrame++) {
    const frame = {
      frameIndex: currentFrame,
      sprites: [],
    };

    // Read frame data
    // frame.numSpritesinFrame = romData.readUInt16BE(currentIndex) + 1; // SprStrNum + 1
    frame.spriteDataOffset = romData.readUInt16BE(currentIndex) + romConfig.addresses.frameOffsets.start - frameOffsetHeaderLength;
    frame.nextOffset = romData.readUInt16BE(currentIndex+2) + romConfig.addresses.frameOffsets.start - frameOffsetHeaderLength;
    frame.numSpritesInFrame = (frame.nextOffset - frame.spriteDataOffset) / 8;
    currentIndex += 2;
    
    console.log(frame);

    // Read sprite data
    let spriteIndex = frame.spriteDataOffset;
    console.log('sprite loop',currentFrame, frame.numSpritesInFrame);
    for (let currentSprite = 0; currentSprite < frame.numSpritesInFrame; currentSprite++) { // assuming there is a dummy frame at the end

      const sprite = {
          spriteIndex: currentSprite,
          xpos: romData.readInt16BE(spriteIndex), // Bytes 0–1: X position
          ypos: romData.readInt16BE(spriteIndex + 2), // Bytes 2–3: Y position
          tileLocByte: romData.readUInt16BE(spriteIndex + 4), // Bytes 4–5: Tile offset
          paletteByte: romData.readUInt8(spriteIndex + 6), // Byte 6: Palette-related
          sizetabByte: romData.readUInt8(spriteIndex + 7), // Byte 7: Size index
        };
      // Parse sprite data
      const parsedData = parseSpriteData(sprite.sizetabByte, sprite.tileLocByte);
      Object.assign(sprite, parsedData);
      
      // console.log(sprite);

      frame.sprites.push(sprite);
      spriteIndex += 8;

      // console.log(frame);
    }
    console.log(frame);
    frames[currentFrame] = frame;
  }

  // Palette handling
  const combinedPalette = Buffer.alloc(64 * 3); // 64 colors (16 per palette * 4), 3 bytes each (RGB)
  let overridePalette = null;

  if (palFile) {
    const palData = fs.readFileSync(palFile);
    if (palData.length !== 32) {
      throw new Error(`Palette file ${palFile} must contain exactly 32 bytes (16 colors). Found ${palData.length} bytes.`);
    }
    overridePalette = Buffer.alloc(16 * 3);
    for (let i = 0; i < 16; i++) {
      const color = palData.readUInt16BE(i * 2);
      const blue = (color >> 9) & 0x07;
      const green = (color >> 5) & 0x07;
      const red = (color >> 1) & 0x07;
      const scaledRed = red * 32;
      const scaledGreen = green * 32;
      const scaledBlue = blue * 32;
      const offset = i * 3;
      overridePalette.writeUInt8(scaledRed, offset);
      overridePalette.writeUInt8(scaledGreen, offset + 1);
      overridePalette.writeUInt8(scaledBlue, offset + 2);
    }
    console.log(`Palette file ${palFile} read and parsed for palette 2 override.`);
  }

  // Default palettes (black if no palette file provided for non-overridden palettes)
  for (let palIndex = 0; palIndex < 4; palIndex++) {
    const animPal = Buffer.alloc(16 * 3);
    if (palIndex === 2 && overridePalette) {
      overridePalette.copy(animPal, 0, 0, 16 * 3);
    } else {
      // Fill with black (or read from ROM if palette offset is provided)
      for (let i = 0; i < 16; i++) {
        // animPal[i] = 0;
        let currentPalIndex = romConfig.addresses.paletteOffset.start + (i*2);
        // console.log('AA TEST',currentPalIndex);
        const color = romData.readUInt16BE(currentPalIndex);

        // Extract 3-bit components (Sega Genesis palette format: 0000BBB0GGG0RRR0)
        const blue = (color >> 9) & 0x07;  // Bits 9–11
        const green = (color >> 5) & 0x07; // Bits 5–7
        const red = (color >> 1) & 0x07;   // Bits 1–3

        // Scale 3-bit values (0–7) to 8-bit (0–255) by multiplying by 32
        const scaledRed = red * 32;
        const scaledGreen = green * 32;
        const scaledBlue = blue * 32;

        // Write RGB values to animPal buffer
        const offset = i * 3;
        animPal.writeUInt8(scaledRed, offset);
        animPal.writeUInt8(scaledGreen, offset + 1);
        animPal.writeUInt8(scaledBlue, offset + 2);
      }
    }
    const combinedOffset = palIndex * 16 * 3;
    animPal.copy(combinedPalette, combinedOffset, 0, 16 * 3);

    // Write palette to .ACT file
    const actBuffer = Buffer.alloc(768);
    animPal.copy(actBuffer, 0, 0, 16 * 3);
    fs.writeFileSync(`Extracted\\${romConfig.name}\\pal${palIndex}.act`, actBuffer);
  }

  // Write combined palette
  const combinedActBuffer = Buffer.alloc(768);
  combinedPalette.copy(combinedActBuffer, 0, 0, 64 * 3);
  fs.writeFileSync(`Extracted\\${romConfig.name}\\palCombined.act`, combinedActBuffer);

  // Process frames and generate images
  for (let currentFrame = 0; currentFrame < numFrames; currentFrame++) {
    let minX, maxX, minY, maxY;

    // Calculate canvas dimensions
    for (let currentSprite = 0; currentSprite < frames[currentFrame].sprites.length; currentSprite++) {
      const sprite = frames[currentFrame].sprites[currentSprite];
      const curMinX = sprite.xpos;
      const curMaxX = curMinX + sprite.dimensions.width * 8;
      const curMinY = sprite.ypos;
      const curMaxY = curMinY + sprite.dimensions.height * 8;

      minX = minX == null || curMinX < minX ? curMinX : minX;
      maxX = maxX == null || curMaxX > maxX ? curMaxX : maxX;
      minY = minY == null || curMinY < minY ? curMinY : minY;
      maxY = maxY == null || curMaxY > maxY ? curMaxY : maxY;
    }

    const frameDimensions = adjustCanvasDimensions(minX || 0, maxX || 0, minY || 0, maxY || 0);
    const spriteCanvas = Array(frameDimensions.maxY).fill().map(() => Array(frameDimensions.maxX).fill(0));

    // Render sprites to canvas
    for (let currentSpriteIndex = 0; currentSpriteIndex < frames[currentFrame].sprites.length; currentSpriteIndex++) {
      const sprite = frames[currentFrame].sprites[currentSpriteIndex];
      const spriteOffset = romConfig.addresses.spriteTiles.start + sprite.tileIndex * 32;
      let idx = spriteOffset;

      for (let curSpriteCol = 0; curSpriteCol < sprite.dimensions.width; curSpriteCol++) {
        for (let curSpriteRow = 0; curSpriteRow < sprite.dimensions.height; curSpriteRow++) {
          for (let curTileRow = 0; curTileRow < 8; curTileRow++) {
            for (let curTileCol = 0; curTileCol < 4; curTileCol++) {
              const pixelXInSprite = curSpriteCol * 8 + curTileCol * 2;
              const pixelYInSprite = curSpriteRow * 8 + curTileRow;

              const flippedX = sprite.hFlip ? (sprite.dimensions.width * 8 - pixelXInSprite - 2) : pixelXInSprite;
              const flippedY = sprite.vFlip ? (sprite.dimensions.height * 8 - pixelYInSprite - 1) : pixelYInSprite;

              const ypixel = sprite.ypos + frameDimensions.offsetY + flippedY;
              const xpixel = sprite.xpos + frameDimensions.offsetX + flippedX;

              if (ypixel >= 0 && ypixel < frameDimensions.maxY && xpixel >= 0 && xpixel < frameDimensions.maxX) {
                const byte = romData[idx];
                const upper = (byte >> 4) & 0x0F;
                const lower = byte & 0x0F;
                const palShift = 16 * sprite.paletteIndex;

                if (sprite.hFlip) {
                  if (lower !== 0) spriteCanvas[ypixel][xpixel] = lower + palShift;
                  if (upper !== 0 && xpixel + 1 < frameDimensions.maxX) spriteCanvas[ypixel][xpixel + 1] = upper + palShift;
                } else {
                  if (upper !== 0) spriteCanvas[ypixel][xpixel] = upper + palShift;
                  if (lower !== 0 && xpixel + 1 < frameDimensions.maxX) spriteCanvas[ypixel][xpixel + 1] = lower + palShift;
                }
              }
              idx++;
            }
          }
        }
      }
    }

    // Save frame data and image
    saveImage(spriteCanvas, frameDimensions.maxX, frameDimensions.maxY, romConfig.name, currentFrame, combinedPalette);
    fs.writeFileSync(`Extracted\\${romConfig.name}\\${currentFrame}.json`, JSON.stringify(frames[currentFrame]));
  }
};

// sizetab table
const sizetabTable = [1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12, 4, 8, 12, 16];

// Dimensions table
const dimensionsTable = [
  { width: 1, height: 1 }, { width: 1, height: 2 }, { width: 1, height: 3 }, { width: 1, height: 4 },
  { width: 2, height: 1 }, { width: 2, height: 2 }, { width: 2, height: 3 }, { width: 2, height: 4 },
  { width: 3, height: 1 }, { width: 3, height: 2 }, { width: 3, height: 3 }, { width: 3, height: 4 },
  { width: 4, height: 1 }, { width: 4, height: 2 }, { width: 4, height: 3 }, { width: 4, height: 4 },
];

// Parse sprite data
function parseSpriteData(sizetabByte, tileLocByte) {
  const sizeIndex = sizetabByte & 0x0F;
  const tileCount = sizetabTable[sizeIndex];
  const dimensions = dimensionsTable[sizeIndex];

  const tileIndexLow = tileLocByte & 0x07FF;
  const tileIndexHigh = (sizetabByte & 0xF0) << 7; // Bits 4–7 of sizetabByte as high bits
  const tileIndex = tileIndexHigh | tileIndexLow;

  const priority = (tileLocByte >> 15) & 1;
  const vFlip = (tileLocByte >> 12) & 1;
  const hFlip = (tileLocByte >> 11) & 1;
  const paletteIndex = (tileLocByte >> 13) & 0x3;

  return {
    sizeIndex, tileCount, dimensions, tileIndex, hFlip, vFlip, paletteIndex, priority,
  };
}

// Adjust canvas dimensions
function adjustCanvasDimensions(minX, maxX, minY, maxY) {
  const width = maxX - minX;
  const height = maxY - minY;
  const offsetX = -minX;
  const offsetY = -minY;

  return {
    minX: 0, minY: 0, maxX: width, maxY: height, offsetX, offsetY,
  };
}

// Save image (BMP and RAW)
function saveImage(spriteArray, width, height, fileName, currentFrame, combinedPalette) {
  const bmpWidth = Math.ceil(width / 4) * 4;
  const bmpHeaderLength = 40;
  const bmpPadding = 14;
  const fullBmpHeaderLength = bmpHeaderLength + bmpPadding;
  const palLength = 256 * 4;
  const unevenImagePadding = (bmpWidth - width) * height;
  const bmpEOFLength = 2;
  const pixelDataLength = width * height;
  const expectedBmpLength = fullBmpHeaderLength + palLength + pixelDataLength + unevenImagePadding + bmpEOFLength;
  const expectedRawLength = pixelDataLength;

  const bmpImage = Buffer.alloc(expectedBmpLength);
  const rawImage = Buffer.alloc(expectedRawLength);

  // BMP header
  bmpImage.write('BM');
  bmpImage.writeUInt32LE(expectedBmpLength, 2);
  bmpImage.writeUInt32LE(fullBmpHeaderLength + palLength, 10);
  bmpImage.writeUInt32LE(bmpHeaderLength, 14);
  bmpImage.writeInt32LE(width, 18);
  bmpImage.writeInt32LE(height * -1, 22);
  bmpImage.writeUInt16LE(1, 26);
  bmpImage.writeUInt16LE(8, 28);
  bmpImage.writeUInt32LE(pixelDataLength + unevenImagePadding + bmpEOFLength, 34);

  // Palette
  for (let i = 0; i < 64; i++) {
    const offset = i * 3;
    bmpImage.writeUInt8(combinedPalette[offset + 2], fullBmpHeaderLength + i * 4); // B
    bmpImage.writeUInt8(combinedPalette[offset + 1], fullBmpHeaderLength + i * 4 + 1); // G
    bmpImage.writeUInt8(combinedPalette[offset], fullBmpHeaderLength + i * 4 + 2); // R
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 3); // A
  }
  for (let i = 64; i < 256; i++) {
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4);
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 1);
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 2);
    bmpImage.writeUInt8(0, fullBmpHeaderLength + i * 4 + 3);
  }

  // Pixel data
  let bufferIndex = fullBmpHeaderLength + palLength;
  let rawIndex = 0;
  let rowCounter = 0;

  for (let yidx = 0; yidx < height; yidx++) {
    for (let xidx = 0; xidx < width; xidx++) {
      const color = spriteArray[yidx][xidx];
      bmpImage.writeUInt8(color, bufferIndex++);
      rowCounter++;
      if (rowCounter === width && unevenImagePadding !== 0) {
        for (let j = 0; j < bmpWidth - width; j++) {
          bmpImage.writeUInt8(0, bufferIndex++);
        }
        rowCounter = 0;
      }
      rawImage.writeUInt8(color, rawIndex++);
    }
  }

  // Write files
  fs.writeFileSync(`Extracted\\${fileName}\\${currentFrame}.bmp`, bmpImage);
  fs.writeFileSync(`Extracted\\${fileName}\\${currentFrame}.raw`, rawImage);

  if (bmpImage.length !== expectedBmpLength || rawImage.length !== expectedRawLength) {
    throw new Error(`Length mismatch: BMP ${bmpImage.length}/${expectedBmpLength}, RAW ${rawImage.length}/${expectedRawLength}`);
  }
}

// Main execution
const romFile = process.argv[2];
const palFile = process.argv[3];
convertRomToBMP(romFile, palFile);