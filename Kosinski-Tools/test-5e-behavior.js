// Let's create a test for just the 0x5E command to understand its behavior
// We need to test different strategies

const fs = require('fs');

// Test data - the exact state before 0x5E command
const testOutputData = [
    0x66, 0x66, 0x66, 0x66, 0x65, 0x55, 0x55, 0x55, 0x65, 0x44, 0x44, 0x44, 0x65, 0x47, 0x77, 0x77,
    0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77,
    0x66, 0x66, 0x66, 0x66, 0x55, 0x55, 0x55, 0x55, 0x44, 0x44, 0x44, 0x44, 0x77, 0x77, 0x77, 0x77,
    0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
    0x66, 0x66, 0x66, 0x66, 0x55, 0x55, 0x55, 0x55, 0x44, 0x44, 0x44, 0x44, 0x77, 0x77, 0x77, 0x77,
    0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x18, 0x77, 0x77, 0x18, 0x88, 0x77, 0x18, 0x88, 0x92,
    0x66, 0x66, 0x66, 0x66, 0x55, 0x55, 0x55, 0x55, 0x44, 0x44, 0x44, 0x44, 0x77, 0x11, 0x11, 0x11,
    0x11, 0x22, 0x28, 0x82, 0x22, 0x33, 0x32, 0x22, 0x34, 0x44, 0x32, 0x98, 0x22, 0x99, 0x98, 0x88,
    0x66, 0x66, 0x66, 0x66, 0x55, 0x55, 0x55, 0x55, 0x44, 0x44, 0x44, 0x44, 0x11, 0x77, 0x77, 0x77,
    0x99, 0x88, 0x11, 0x77, 0x98, 0x11, 0x18, 0x77, 0x81, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x66, 0x66, 0x66, 0x66, 0x55, 0x55, 0x55, 0x55, 0x44, 0x44, 0x44, 0x44, 0x77, 0x77, 0x77, 0x77,
    0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x82, 0x87, 0x77, 0x77,
    0x66, 0x66, 0x66, 0x61, 0x55, 0x55, 0x55, 0x21, 0x44, 0x44, 0x43, 0x21, 0x77, 0x77, 0x73, 0x21,
    0x77, 0x77, 0x73, 0x21, 0x77, 0x77, 0x73, 0x21, 0x77, 0x77, 0x73, 0x21, 0x77, 0x77, 0x73, 0x21,
    0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77,
    0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77, 0x65, 0x47, 0x77, 0x77,
    0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x71
];

const expectedOutput = [0x77, 0x77, 0x77, 0x18, 0x77, 0x77, 0x77, 0x18, 0x77, 0x77, 0x77, 0x18, 0x77, 0x77];

console.log("Testing different 0x5E implementations:");
console.log("Expected output:", expectedOutput.map(b => b.toString(16).padStart(2, '0')).join(' '));

// Strategy 1: Current implementation - copy from offset -(lowNibble + 2)
const strategy1 = [];
const offset1 = 14 + 2; // 16
const start1 = testOutputData.length - offset1;
for (let i = 0; i < 16; i++) {
    if (start1 + i >= 0 && start1 + i < testOutputData.length) {
        strategy1.push(testOutputData[start1 + i]);
    }
}
console.log("Strategy 1 (current):", strategy1.map(b => b.toString(16).padStart(2, '0')).join(' '));

// Strategy 2: Find pattern and repeat it
const pattern = [0x77, 0x77, 0x77, 0x18];
let patternStart = -1;
for (let i = 0; i <= testOutputData.length - 4; i++) {
    if (testOutputData[i] === pattern[0] && 
        testOutputData[i+1] === pattern[1] && 
        testOutputData[i+2] === pattern[2] && 
        testOutputData[i+3] === pattern[3]) {
        patternStart = i;
        break;
    }
}

const strategy2 = [];
if (patternStart >= 0) {
    for (let i = 0; i < 16; i++) {
        strategy2.push(pattern[i % 4]);
    }
}
console.log("Strategy 2 (repeat pattern):", strategy2.map(b => b.toString(16).padStart(2, '0')).join(' '));

// Strategy 3: Copy from specific offset based on pattern analysis
// The pattern starts at position 84, which is 184 bytes from end
// Maybe 0x5E uses lowNibble * some_multiplier as offset?
const strategy3 = [];
const offset3 = 184; // Direct offset where pattern starts
const start3 = testOutputData.length - offset3;
for (let i = 0; i < 16; i++) {
    if (start3 + i >= 0 && start3 + i < testOutputData.length) {
        strategy3.push(testOutputData[start3 + i]);
    }
}
console.log("Strategy 3 (fixed offset):", strategy3.map(b => b.toString(16).padStart(2, '0')).join(' '));

// Check which strategy matches
console.log("\nComparison:");
console.log("Expected:  ", expectedOutput.map(b => b.toString(16).padStart(2, '0')).join(' '));
console.log("Strategy 2:", strategy2.map(b => b.toString(16).padStart(2, '0')).join(' '));
console.log("Match:", JSON.stringify(expectedOutput) === JSON.stringify(strategy2.slice(0, 14)));

// The key insight: 0x5E should repeat the pattern [77,77,77,18] for 16 bytes total
// but only output 14 bytes (since the expected output is 14 bytes, not 16)

const correctOutput = [];
for (let i = 0; i < 14; i++) { // Only 14 bytes as per expected
    correctOutput.push(pattern[i % 4]);
}
console.log("Correct (14 bytes):", correctOutput.map(b => b.toString(16).padStart(2, '0')).join(' '));
console.log("Matches expected:", JSON.stringify(expectedOutput) === JSON.stringify(correctOutput));
